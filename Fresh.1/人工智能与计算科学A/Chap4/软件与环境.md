<style>
    body {
        font-size: 13.5px;
        font-family: "Microsoft YaHei", "微软雅黑";
        line-height: 1.6;
    }
</style>
# 四、软件与环境

## 1. 程序设计

### 1.1 面向过程编程设计特点

结构化程序设计方法是面向过程编程应遵循的基本方法和原则。主要包括：

1. 只采用三种基本的程序控制结构（顺序、选择、循环）来编制程序，从而使程序具有良好的结构；
2. 程序设计自顶而下；
3. 用结构化程序设计流程图表示算法。

## 1.2 计算机语言处理系统

![alt text](image.png)

![alt text](image-1.png)

## 2. 算法基础

### 2.1 图灵机与可计算

#### 2.1.1 图灵机

图灵机包括以下四个部分：

1. 一条**无限长的纸带**，用于使用二进制符号来表达计算所用的数据和控制规则；

2. 一个**读写头**，用于获取或者改写纸带当前位置上的符号；

3. 一个**状态寄存器**，用于保存图灵机当前所处的状态（包括停机状态）；

4. 一套**控制规则**，它根据当前机器所处的状态以及当前读写头所获取的符号，来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态。

#### 2.1.2 可计算

可计算性是指对于给定的问题，是否存在一种算法可以解决它。

![alt text](image-2.png)

![alt text](image-3.png)

### 2.2 算法复杂度

#### 2.2.1 时间复杂度

计算所需的步数或指令条数.

![alt text](image-4.png)

#### 2.2.2 空间复杂度

计算所需的存储空间大小。

### 2.3 算法的特点

算法具有以下基本特征：

- 有穷性：一个算法必须在执行有限个操作步骤后终止

- 确定性：算法中每一步的含义必须是确切的，不可出现任何二义性

- 有效性：算法中的每一步操作都应该能有效执行，一个不可执行的操作是无效的

- 有零个或多个输入：这里的输入是指在算法开始之前所需要的初始数据，输入的多少取决于特定的问题

- 有一个或多个输出：所谓输出是指与输入有某种特定关系的量，在一个完整的算法中至少会有一个输出。

### 2.4 流程图表示算法

![alt text](image-5.png)

![alt text](image-6.png)

```mermaid
graph LR
    A([Start]) --> B[/Input n/]
    B --> C[Initialize i = 1]
    C --> D{Is i <= n?}
    D -- Yes --> E[Output i asterisks]
    E --> F[Increment i, i = i + 1]
    F --> D
    D -- No --> G([End])
```
![alt text](image-7.png)

**冒泡排序**

```mermaid
graph LR
    A(Start) --> B[Input 30 students' scores]
    B --> C[Initialize i = 0]
    C --> D{Is i < 29?}
    D -- Yes --> E[Initialize j = 0]
    E --> F{Is j < 30 - i - 1?}
    F -- Yes --> G{Is score~j > score~j+1?}
    G -- Yes --> H[Swap score~j and score~j+1]
    G -- No --> I[Continue next comparison]
    H --> I
    I --> J[Increment j, j = j + 1]
    J --> F
    F -- No --> K[Increment i, i = i + 1]
    K --> D
    D -- No --> L[Sorting complete, output scores]
```

**选择排序**

```mermaid
graph LR
    A([Start]) --> B[/Input 30 students' scores/]
    B --> C[Initialize i = 0]
    C --> D{i < 29?}
    D -- Yes --> E[Initialize minIndex = i]
    E --> F[Initialize j = i + 1]
    F --> G{j < 30?}
    G -- Yes --> H{score~j < score~minIndex?}
    H -- Yes --> I[minIndex = j]
    H -- No --> J[Continue next comparison]
    I --> J
    J --> K[Increment j, j = j + 1]
    K --> G
    G -- No --> L{minIndex != i?}
    L -- Yes --> M[Swap score~i and score~minIndex]
    L -- No --> N[Continue next iteration]
    M --> N
    N --> O[Increment i, i = i + 1]
    O --> D
    D -- No --> P([Sorting complete, output scores])
```

**插入排序**

```mermaid
graph   LR
    A([Start]) --> B[/Input 30 students' scores/]
    B --> C[Initialize i = 1]
    C --> D{i < 30?}
    D -- Yes --> E[Initialize key = score~i]
    E --> F[Initialize j = i - 1]
    F --> G{j >= 0 and score~j > key?}
    G -- Yes --> H[score~j+1 = score~j]
    H --> I[Decrement j, j = j - 1]
    I --> G
    G -- No --> J[score~j+1 = key]
    J --> K[Increment i, i = i + 1]
    K --> D
    D -- No --> L([Sorting complete, output scores])
```












